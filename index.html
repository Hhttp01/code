<!DOCTYPE html>
<html lang="he" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Path Forge Pro | System Sync</title>
    
    <script src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/lucide@latest"></script>

    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;600;800&family=Fira+Code&display=swap');
        
        :root { --accent: #3b82f6; }
        body { font-family: 'Inter', sans-serif; background-color: #020617; color: #f8fafc; overflow: hidden; }
        .mono { font-family: 'Fira Code', monospace; }
        
        /* Custom UI Elements */
        .glass-panel { background: rgba(15, 23, 42, 0.6); backdrop-filter: blur(12px); border: 1px solid rgba(51, 65, 85, 0.5); }
        .custom-scrollbar::-webkit-scrollbar { width: 4px; }
        .custom-scrollbar::-webkit-scrollbar-thumb { background: #1e293b; border-radius: 10px; }
        .editor-area { background: radial-gradient(circle at top right, #0f172a, #020617); }
        
        /* Animations */
        .fade-in { animation: fadeIn 0.4s ease-out; }
        @keyframes fadeIn { from { opacity: 0; transform: translateY(10px); } to { opacity: 1; transform: translateY(0); } }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useCallback } = React;

        const App = () => {
            const [projectName, setProjectName] = useState("");
            const [tree, setTree] = useState(null);
            const [pathInput, setPathInput] = useState("");
            const [editingFile, setEditingFile] = useState(null);
            const [expandedFolders, setExpandedFolders] = useState(new Set(['root']));
            const [isSyncing, setIsSyncing] = useState(false);
            const [contextMenu, setContextMenu] = useState(null);

            // --- Local Storage Sync ---
            useEffect(() => {
                const savedData = localStorage.getItem('pathforge_pro_v1');
                if (savedData) {
                    const { tree: savedTree, projectName: savedName } = JSON.parse(savedData);
                    setTree(savedTree);
                    setProjectName(savedName);
                }
            }, []);

            useEffect(() => {
                if (tree) {
                    localStorage.setItem('pathforge_pro_v1', JSON.stringify({ tree, projectName }));
                }
                if (window.lucide) lucide.createIcons();
            }, [tree, projectName]);

            // --- Real System Export Logic ---
            const syncToLocalSystem = async () => {
                try {
                    if (!tree) return;
                    setIsSyncing(true);
                    
                    const rootHandle = await window.showDirectoryPicker();
                    
                    const writeNode = async (node, parentHandle) => {
                        if (node.type === 'file') {
                            // ×¡×™× ×•×Ÿ ×§×‘×¦×™× ×¨×™×§×™× - ×”×“×¨×™×©×” ×©×œ×š
                            if (node.content && node.content.trim().length > 0) {
                                const fileHandle = await parentHandle.getFileHandle(node.name, { create: true });
                                const writable = await fileHandle.createWritable();
                                await writable.write(node.content);
                                await writable.close();
                            }
                        } else {
                            const dirHandle = await parentHandle.getDirectoryHandle(node.name, { create: true });
                            for (const child of node.children) {
                                await writeNode(child, dirHandle);
                            }
                        }
                    };

                    for (const child of tree.children) {
                        await writeNode(child, rootHandle);
                    }
                    alert("ðŸš€ ×¡× ×›×¨×•×Ÿ ×”×•×©×œ×! ×”×§×‘×¦×™× ×¢× ×”×ª×•×›×Ÿ × ×•×¦×¨×• ×‘×ž×—×©×‘.");
                } catch (err) {
                    if (err.name !== 'AbortError') alert("×©×’×™××” ×‘×’×™×©×” ×œ×ª×™×§×™×™×”.");
                } finally {
                    setIsSyncing(false);
                }
            };

            const addPath = () => {
                if (!pathInput.trim()) return;
                const parts = pathInput.split('/').filter(Boolean);
                const newTree = { ...tree };
                let current = newTree;

                parts.forEach((part, i) => {
                    const isFile = i === parts.length - 1 && part.includes('.');
                    let found = current.children.find(c => c.name === part);
                    if (!found) {
                        found = {
                            id: Math.random().toString(36).substr(2, 9),
                            name: part,
                            type: isFile ? 'file' : 'folder',
                            content: isFile ? '' : undefined,
                            children: isFile ? undefined : []
                        };
                        current.children.push(found);
                    }
                    if (found.type === 'folder') {
                        current = found;
                        setExpandedFolders(prev => new Set(prev).add(found.id));
                    }
                });
                setTree(newTree);
                setPathInput("");
            };

            const TreeNode = ({ node, depth = 0, parent }) => {
                const isExpanded = expandedFolders
